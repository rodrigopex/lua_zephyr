/**
 * @file lua_msg_descr_pb.h
 * @brief Bridge between nanopb FIELDLIST X-macros and lua_msg_field_descr arrays.
 *
 * Automatically generates lua_msg_field_descr arrays from nanopb-generated
 * FIELDLIST macros, making the .proto file the single source of truth for
 * both protobuf serialization and Lua table conversion.
 *
 * Usage:
 *   #include <lua_zephyr/lua_msg_descr_pb.h>
 *   #include "channels.pb.h"
 *
 *   LUA_PB_DESCR_DEFINE(msg_acc_data);
 *   ZBUS_CHAN_DEFINE(chan_acc_data, struct msg_acc_data, NULL,
 *                    LUA_PB_DESCR_REF(msg_acc_data), ...);
 *
 * For nested MESSAGE fields, ensure the child descriptor is defined before
 * the parent (leaf-first ordering). The parent auto-resolves submessage
 * fields via nanopb's <parent_t>_<field>_MSGTYPE macros:
 *
 *   LUA_PB_DESCR_DEFINE(msg_acc_data);
 *   LUA_PB_DESCR_DEFINE(msg_sensor_config);
 *   ZBUS_CHAN_DEFINE(chan_sensor_config, ...);
 *
 * Limitations:
 *   - ONEOF fields not supported (fieldname is a tuple)
 *   - REPEATED/FIXARRAY fields not supported
 *   - Only STATIC allocation type supported
 */

#ifndef LUA_MSG_DESCR_PB_H
#define LUA_MSG_DESCR_PB_H

#include <lua_zephyr/lua_msg_descr.h>

/* clang-format off */

/**
 * @brief Type-mapping macros: nanopb ltype -> LUA_MSG_FIELD invocation.
 *
 * Each LUA_PB_GEN_<ltype> maps a nanopb logical type to the appropriate
 * lua_msg_field_descr entry. The _name parameter is the struct tag name
 * (without 'struct' prefix); the 'struct' keyword is added internally.
 */
#define LUA_PB_GEN_BOOL(_name, f)            LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_BOOL)
#define LUA_PB_GEN_INT32(_name, f)           LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_SINT32(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_SFIXED32(_name, f)        LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_INT64(_name, f)           LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_SINT64(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_SFIXED64(_name, f)        LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_UINT32(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_UINT)
#define LUA_PB_GEN_FIXED32(_name, f)         LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_UINT)
#define LUA_PB_GEN_UINT64(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_UINT)
#define LUA_PB_GEN_FIXED64(_name, f)         LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_UINT)
#define LUA_PB_GEN_FLOAT(_name, f)           LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_NUMBER)
#define LUA_PB_GEN_DOUBLE(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_NUMBER)
#define LUA_PB_GEN_STRING(_name, f)          LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_STRING_BUF)
#define LUA_PB_GEN_ENUM(_name, f)            LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_INT)
#define LUA_PB_GEN_UENUM(_name, f)           LUA_MSG_FIELD(struct _name, f, LUA_MSG_TYPE_UINT)

/**
 * @brief Auto-resolve nested MESSAGE fields via nanopb MSGTYPE macros.
 *
 * Uses <parent_t>_<field>_MSGTYPE (generated by nanopb) and Zephyr's CONCAT
 * macro to resolve the child's lua_fields array automatically.
 * Requires the child LUA_PB_DESCR_DEFINE to precede the parent (leaf-first).
 */
#define LUA_PB_GEN_MESSAGE(_name, f)                                           \
	{                                                                      \
		.field_name = #f,                                              \
		.type = LUA_MSG_TYPE_OBJECT,                                   \
		.offset = offsetof(struct _name, f),                           \
		.size = sizeof(((struct _name *)0)->f),                        \
		.sub_fields = CONCAT(_name##_t_##f##_MSGTYPE,                 \
				     _lua_fields),                             \
		.sub_field_count = sizeof(                                     \
			CONCAT(_name##_t_##f##_MSGTYPE, _lua_fields))    \
			/ sizeof(struct lua_msg_field_descr),                  \
	}

/**
 * @brief X-macro callback: dispatches on nanopb ltype via token pasting.
 *
 * Called by the nanopb-generated FIELDLIST macro for each field.
 * Ignores atype, htype, and tag; dispatches solely on ltype.
 *
 * @param _name       The struct tag name (passed as the accumulator 'a').
 * @param atype       Allocation type (STATIC, POINTER, CALLBACK) - ignored.
 * @param htype       Handling type (REQUIRED, OPTIONAL, etc.) - ignored.
 * @param ltype       Logical type (INT32, UINT32, STRING, etc.) - used for dispatch.
 * @param fieldname   The C struct field name.
 * @param tag         Proto field tag number - ignored.
 */
#define LUA_PB_GEN_FIELD(_name, atype, htype, ltype, fieldname, tag) \
	LUA_PB_GEN_##ltype(_name, fieldname),

/**
 * @brief Define a named descriptor and fields array from a nanopb FIELDLIST.
 *
 * Creates a static const field array <_name>_t_lua_fields[] and a descriptor
 * struct <_name>_descr. The named array enables automatic submessage resolution
 * via nanopb's MSGTYPE macros.
 *
 * Child descriptors must be defined before parents (leaf-first ordering).
 *
 * @param _name  The struct tag name (e.g. msg_acc_data).
 */
#define LUA_PB_DESCR_DEFINE(_name)                                             \
	static const struct lua_msg_field_descr _name##_t_lua_fields[] = {     \
		_name##_FIELDLIST(LUA_PB_GEN_FIELD, _name)                     \
	};                                                                     \
	const struct lua_msg_descr CONCAT(_name, _descr) = {                   \
		.fields = _name##_t_lua_fields,                                \
		.field_count = sizeof(_name##_t_lua_fields)                    \
			/ sizeof(struct lua_msg_field_descr),                  \
		.msg_size = sizeof(struct _name),                              \
	}

#define LUA_PB_DESCR_REF(_name) ((void *)&CONCAT(_name, _descr))

/* clang-format on */

#endif /* LUA_MSG_DESCR_PB_H */
